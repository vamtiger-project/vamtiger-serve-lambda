{"version":3,"file":"index.js","sources":["../source/index.ts"],"sourcesContent":["import { resolve as resolvePath } from 'path';\nimport { IncomingMessage, ServerResponse, Server } from 'http';\nimport Require from 'vamtiger-require';\nimport startServer, { getBody, HeaderKey, HeaderValue} from 'vamtiger-debug-server';\nimport Args from 'vamtiger-argv/build/main';\n\nexport interface IParams {\n    port: number | string;\n    handleRequestPath: string;\n    path: string;\n}\n\nexport interface ISendResponseParams {\n    error: Error|null|undefined;\n    result: IResponse;\n    response: ServerResponse\n}\n\nexport interface AnyObject {\n    [key: string]: any\n}\n\nexport interface IEvent {\n    body?: string;\n}\n\nexport interface IBody {\n    hello: string;\n}\n\nexport interface ILamdaResponse {\n    statusCode: number;\n    body?: string;\n    error?: Error;\n}\n\nexport interface IResponse {\n    statusCode: ILamdaResponse['statusCode'];\n    error?: ILamdaResponse['error'];\n    body?: AnyObject;\n}\n\nexport interface IGetLambdaPathParams {\n    path?: string;\n}\n\nexport enum CommandlineArguments {\n    path = 'path',\n    P = 'P',\n    port = 'port',\n    p = 'p',\n    handleRequest = 'handleRequest',\n    H = 'H',\n    body = 'body',\n    b = ''\n}\n\nexport enum ErrorMessage {\n    lambdaPath = 'No Lamda path defined'\n}\n\nexport type Callback<T> = (error: Error|null|undefined, result: T) => void;\n\nexport type Lamda = (event: IEvent, context: AnyObject, callback: Callback<IResponse>) => Promise<void>;\n\nconst args = new Args();\nconst defaults = {\n    event: {\n        body: '{}'\n    },\n    context: {}\n};\nconst bodyResponse = args.get(CommandlineArguments.b) || args.get(CommandlineArguments.body);\n\nlet server: Server | undefined;\nlet lamda: Lamda;\n\nexport default async function startLambdaSever({ port, handleRequestPath, path: lambdaPath}: IParams) {\n    lamda = lambdaPath && Require({\n        path: lambdaPath\n    });\n\n    server = await startServer({\n        port,\n        handleRequest: handleRequestPath\n    });\n}\n\nexport async function stopLambdaServer() {\n    if (server) {\n        server.close();\n    }\n\n    server = undefined;\n}\n\nexport async function handleRequest(request: IncomingMessage, response: ServerResponse) {\n    const body = await getBody({ request });\n    const event = body && {\n        body: JSON.stringify(body)\n    } || defaults.event;\n    const context = defaults.context;\n\n    await lamda(\n        event,\n        context,\n        (error: Error|null|undefined, result: IResponse) => sendResponse({ error, result, response})\n    );\n}\n\nexport function sendResponse({ error, result, response}: ISendResponseParams) {\n    let responseData = {}  as IResponse | AnyObject;\n\n    response.setHeader(HeaderKey.contentType, HeaderValue.json);\n\n    if (error) {\n        responseData.statusCode = result.statusCode || 500;\n        responseData.error = error;\n    } else if (result.body && typeof result.body === 'string') {\n        result.body = !bodyResponse && JSON.parse(result.body);\n        responseData = bodyResponse && result.body || result;\n    }\n\n    response.end(JSON.stringify(responseData));\n}\n\nexport function getLambdaPath({ path: relativePath }: IGetLambdaPathParams) {\n    const workingDirectory = process.cwd();\n    const packagePath = resolvePath(\n        workingDirectory,\n        'package'\n    );\n    const mainPath = Require({\n        path: `${packagePath}.main`\n    });\n    const lambdaPath = resolvePath(\n        workingDirectory,\n        relativePath || `${mainPath}.default`\n    );\n\n    return lambdaPath;\n}"],"names":["CommandlineArguments","ErrorMessage","args","Args","defaults","event","body","context","bodyResponse","get","b","server","lamda","startLambdaSever","port","handleRequestPath","path","lambdaPath","Require","startServer","handleRequest","stopLambdaServer","close","undefined","request","response","getBody","JSON","stringify","error","result","sendResponse","responseData","setHeader","HeaderKey","contentType","HeaderValue","json","statusCode","parse","end","getLambdaPath","relativePath","workingDirectory","process","cwd","packagePath","resolvePath","mainPath"],"mappings":"woBA8CA,SAAYA,GACRA,cACAA,QACAA,cACAA,QACAA,gCACAA,QACAA,cACAA,OARJ,CAAYA,+BAAAA,mCAWAC,uBAAAA,6DAQZ,MAAMC,KAAO,IAAIC,KACXC,UACFC,OACIC,KAAM,MAEVC,YAEEC,aAAeN,KAAKO,IAAIT,6BAAqBU,IAAMR,KAAKO,IAAIT,6BAAqBM,MAEvF,IAAIK,OACAC,MAEJ,SAA8BC,kBAAiBC,KAAEA,EAAIC,kBAAEA,EAAmBC,KAAMC,oDAC5EL,MAAQK,GAAcC,SAClBF,KAAMC,IAGVN,aAAeQ,sBACXL,KAAAA,EACAM,cAAeL,MAIvB,SAAsBM,mEACdV,QACAA,OAAOW,QAGXX,YAASY,IAGb,SAAsBH,cAAcI,EAA0BC,mDAC1D,MAAMnB,QAAaoB,qBAAUF,QAAAA,IACvBnB,EAAQC,IACVA,KAAMqB,KAAKC,UAAUtB,KACpBF,SAASC,MACRE,EAAUH,SAASG,cAEnBK,MACFP,EACAE,EACA,CAACsB,EAA6BC,IAAsBC,cAAeF,MAAAA,EAAOC,OAAAA,EAAQL,SAAAA,OAI1F,SAAgBM,cAAaF,MAAEA,EAAKC,OAAEA,EAAML,SAAEA,IAC1C,IAAIO,KAEJP,EAASQ,UAAUC,sBAAUC,YAAaC,wBAAYC,MAElDR,GACAG,EAAaM,WAAaR,EAAOQ,YAAc,IAC/CN,EAAaH,MAAQA,GACdC,EAAOxB,MAA+B,iBAAhBwB,EAAOxB,OACpCwB,EAAOxB,MAAQE,cAAgBmB,KAAKY,MAAMT,EAAOxB,MACjD0B,EAAexB,cAAgBsB,EAAOxB,MAAQwB,GAGlDL,EAASe,IAAIb,KAAKC,UAAUI,IAGhC,SAAgBS,eAAgBzB,KAAM0B,IAClC,MAAMC,EAAmBC,QAAQC,MAC3BC,EAAcC,aAChBJ,EACA,WAEEK,EAAW9B,SACbF,QAAS8B,WAOb,OALmBC,aACfJ,EACAD,MAAmBM"}